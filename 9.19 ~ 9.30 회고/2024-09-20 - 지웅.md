# 📝 2024.09.20 회고 📝
#### 1. 수업 내용 복습정리
#### 2. 오류
#### 3. 백준


## API 문서화(API Documentation)

### 1. API 문서화 개요
#### 1.1 API(Application Programming Interface)
- API는 서버와 클라이언트 간의 데이터 교환을 원활하게 도와주는 매개체입니다. API를 사용하면 클라이언트가 서버로 쉽게 요청을 보내고, 서버에서 응답을 받을 수 있어 개발 복잡도가 줄어듭니다. API는 재사용이 가능해 시간과 비용을 절감할 수 있습니다.

###### 비유: API는 식당의 메뉴판과 같아서 사용자는 주방의 복잡한 과정 없이 원하는 요리를 주문할 수 있습니다.

#### 1.2 API 문서(API Documentation)
- API 문서는 API 사용법을 개발자에게 설명하는 자료입니다. API의 기능을 쉽게 구현할 수 있도록 상세한 가이드를 제공하여, 개발자가 API의 요청/응답 형식, 파라미터 설명, 오류 처리 방법 등을 이해할 수 있게 도와줍니다.

##### API 문서의 필요성:

- API 기능과 사용 방법을 명확하게 파악 가능
- 요청 및 응답 형식, 파라미터 설명
- 문제 해결 지원
- 협업 시 일관성 제공
  
### 2. 좋은 API 문서의 핵심 요소
#### 2.1 가독성
- API 문서는 쉽게 읽히고 이해할 수 있어야 합니다. 제목, 부제목, 리스트, 도표 등을 활용해 시각적으로 편리하게 구성하는 것이 중요합니다.

###### 툴 추천: Swagger, Postman, Document360

#### 2.2 목적성
- 문서의 서두에 API의 핵심 기능과 역할을 명확히 제시하여 사용자가 API를 제대로 이해할 수 있게 합니다.

#### 2.3 간결성
- API 문서는 기술적으로 복잡한 내용을 간결하게 다루어야 하며, 핵심 내용에 집중해 불필요한 설명은 줄여야 합니다.

#### 2.4 체계성
- 문서는 논리적으로 구성되어 필요한 정보를 쉽게 찾을 수 있어야 합니다. 목차와 섹션을 체계적으로 배열하여 사용자가 쉽게 탐색할 수 있게 해야 합니다.

#### 2.5 일관성
- 일관된 용어와 스타일을 유지하여 문서의 신뢰성을 높이고, 파라미터 명명 규칙 및 응답 데이터 구조의 일관성을 유지해 사용성을 높입니다.

#### 2.6 사용자 친화적
- 기술 용어를 설명하고 다양한 기술 수준의 사용자를 고려하여 문서를 작성해야 합니다.

#### 2.7 다양한 예시
- 요청/응답 파라미터, 헤더, 코드 예시 등을 포함해 API의 동작을 설명하고 다양한 활용 예시를 제공해야 합니다.

### 3. API 문서화란?
- API 문서화는 API 사용에 필요한 모든 정보를 문서로 제공하는 과정입니다. API 문서는 개발자 간의 소통을 원활하게 하고, 변경 사항을 쉽게 전달하며, API 사용성을 극대화합니다.

###### API 문서화의 장점:

- 개발 생산성 향상
- API 채택률 증가
- 신속한 문제 해결
- 일관된 사용 경험 제공
- 보안 강화 및 API 품질 보장

### 4. API 문서화의 주요 구성 요소
#### 4.1 API 개요 및 소개
- API가 제공하는 기능과 목적을 간략하게 설명합니다.

#### 4.2 인증 정보
- API 호출에 필요한 인증 방법(API 키, OAuth, JWT 등)을 설명하고, 인증 절차를 명시합니다.

#### 4.3 엔드포인트
- API 각 기능에 접근하는 URI와 HTTP 메서드(GET, POST, PUT, DELETE)를 명시합니다.

#### 4.4 요청 및 응답 형식
- 요청 시 필요한 파라미터와 응답 형식을 설명합니다. 요청 파라미터의 필드명, 필수 여부, 기본값 등을 포함합니다.

### 5. API 문서화 도구
#### 5.1 Swagger
- Swagger는 API 문서화를 위한 도구로, Web API 스펙을 관리하고 자동 문서화를 지원합니다. Swagger를 사용하면 API가 수정되어도 문서가 자동 갱신됩니다.

##### 장점: 아름다운 UI, API 테스트 기능 제공
##### 단점: 문서 신뢰도를 높게 유지하기 어려움

#### 5.2 Spring REST Docs
- Spring REST Docs는 Spring 프레임워크를 사용해 REST API에 대한 문서를 자동 생성하는 도구입니다. 테스트 코드 기반으로 문서가 생성되므로 높은 신뢰도를 유지할 수 있습니다.

#### 5.3 OpenAPI Specification (OAS)
- OpenAPI는 RESTful API 스펙을 문서화하는 표준 명세로, Swagger와 결합하여 사용되며 JSON이나 YAML 형식으로 문서화됩니다.

### 6. 파이썬 API 문서화
#### 6.1 Doc String
- 파이썬에서 함수, 클래스, 메소드 등에 설명을 추가하는 메타데이터로, 코드 문서화와 유지보수에 도움을 줍니다.

###### Doc String의 중요성:

- 코드 문서화
- 자동 문서 생성
- IDE와 통합
- Doc String을 적절히 활용해 Python API 문서를 쉽게 관리할 수 있습니다.

### 더 자세하게 정리된거는 아래 블로그를 통해 확인할 수 있습니다.
https://kgw08003.tistory.com/74


## 오류

- 초반에 `python manage.py runserver` 하려고 했는데 `ModuleNotFoundError: No module named 'pkg_resources'` 오류가 발생하였다.
- 에러 메시지를 보면 `pkg_resources` 모듈을 찾을 수 없다는 오류였고, 검색 결과 이 모듈이 `setuptools` 패키지 내에 포함되어있다는 것을 알게 되었다.
- 확인 결과 `setuptools` 가 설치되지 않았거나 손상된 경우 발생하는 문제라고 해서, 이를 해결하고자 패키지를 다시 설치하거나 업데이트 하는것 중에서 업데이트를 하는 방법을 택했었다.
``` pip install --upgrade setuptools ```

- 두번째로 `Sphinx` 를 실습하는 도중에 `sudo apt install tree` 이 커멘드가 윈도우에서 먹히지 않는것을 확인했다.
- 윈도우에서는 `tree` 명령어를 사용하려면 `tree` 유틸리티를 설치해야하고, `apt` 명령어 대신 다른 방법을 사용해야한다는 것을 알게되었다.
- `winget` 패키지 관리자를 사용하는 방법과 `Git Bash, WSL(Windows Subsystem for Linux)`를 이용하는 방법이 존재한다고 한다.
- 저는 여기서 `winget install GNU.tree` 명령어를 이용해서 `tree`를 이용할 수 있게 해봤다.(아직 뒷부분은 시도해보지 않아서 제대로 동작하는지는 확인하지는 못했다)

- 이것 이외의 오류는 오타 오류를 제외하고는 나왔던 오류는 없는 것 같다.


## 백준
- 백준 2720번 세탁소 사장 동혁
- https://www.acmicpc.net/problem/2720

이번 문제는 단순 그리드서치 문제였다.
```
Z = int(input())

for a in range(Z):
    C = int(input())
    for i in [25, 10, 5, 1]:
        count = C // i  
        print(count, end=" ")  
        C = C % i  
    print()
```
- 어차피 금액 단위가 정해져 있으니, 큰 단위부터 몫을 반환하고 나머지를 다시 금액으로 할당, 이 과정을 반복하면 되는 문제였다.
- 처음에는 반복 과정에서 for문을 쓰지 않고 그냥 quarter = c // 25, dime = (c - 25*quarter - 10*dime) // 5 이런식으로 단순하게 접근했었는데, 생각해보니까 어차피 금액 단위가 정해져 있다는 사실을 알고 이를 활용해서 이중 for문을 생각했던 것 같다.

- 풀이를 마치고 다른사람들이 한 코드를 보는 와중 신기한 방법을 쓰신분을 발견해서 올려보겠다.
```
for i in range(T):
  result=[]
  C = int(input())
  quarter = (C//25)
  left_q = C%25
  result.append(int(quarter))
  
  dime = (left_q//10)
  left_d = left_q%10
  result.append(int(dime))
  
  nickel = (left_d//5)
  left_n = left_d%5
  result.append(int(nickel))
  
  penny =(left_n//1)
  left_p = left_n%1
  result.append(int(penny))
  
  final.append(result)
for i in final:
  print(*i)
```
- 위에서 받은 입력값 T 만큼 반복을 진행하고
- 이때 각 반복에 해당하는 결과를 리스트에 담고자 result 변수를 선언했다. 반복할때마다 새로 선언되어 새로운 경우 반영함에 주목.
- 거스름돈을 나타내는 C는 정수로 이루어져 있기 때문에 이에 맞춰 쿼터, 다임, 니켈, 페니의 단위도 정수로 바꿔주었다.
- 쿼터, 다임, 니켈, 페니 순서대로 필요한 개수를 출력하기 위해 계산할 때도 같은 순서로 진행한다.
- 이때 각 순서의 앞에서 얻은 몫 값은 해당 단위의 개수에 해당하고 나머지는 그 다음 단위의 개수 계산에 영항을 미침에 주의.
- 그래서 쿼터, 다임에 해당하는 코드를 보면 C의 몫은 쿼터의 개수 , C의 나머지는 다임의 개수 계산에 영향을 미치게 된다.
- 최종적으로 각 입력에 해당하는 결과값을 result 에 담고 이를 final 리스트에 넣는다.
- 결국 i에서 final리스트의 0번째 요소부터 차례대로 들어가는데, 이때 각 테스트케이스에 해당하는 리스트 결과값을 반환하게 되는 것이다.
- 여기서 특이한게 이 분은 출력할때 리스트를 의미하는 대괄호를 없애기 위해서 `Asterisk`를 사용했다는 것이다.

##### 에스터리스크
- 에스터리스크는 언팩킹 이라고 하며, 리스트의 요소를 개별 인자로 확장하여 전달하는 역할을 한다. 이 방법을 사용하면 리스트의 각 요소를 개별적으로 출력할 수 있다고 한다.

##### 에스터리스크의 역활
1. 리스트 언팩킹 : *i를 사용하면 i의 모든 요소가 개별 인자로 취급된다. ex) i가 [1,2,3]이라면 print(*i)는 실제로 print(1,2,3)과 동일한 효과를 내는 것이다.
2. 가독성 향상 : 이 방식은 여러 값을 한 번에 출력하는 경우 코드가 더 간결하고 읽기 쉽게 만들어주는 효과를 가진다.
3. 유연성 : 리스트의 길이에 관계없이 모든 요소를 출력할 수 있기 때문에, 고정된 수의 인자를 다루는 것보다 훨씬 유연하게 사용될 수 있다고 한다.

- 예시
```
final = [
    [2, 1, 0, 3],  # 첫 번째 테스트 케이스 결과
    [1, 0, 0, 4],  # 두 번째 테스트 케이스 결과
]
```
- 위와같이 `final 리스트` 형태라 가정하면
- `print(*i)`는 아래와 같이 출력된다.
```
2 1 0 3
1 0 0 4
```
이와 같이 각 동전의 개수를 개별적으로 출력할 수 있게 해주는 것이다.
