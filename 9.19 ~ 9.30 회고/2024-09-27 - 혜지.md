# 📌 9월 27일 회고
## 🔍 회고 내용
### 1. AWS 실습, 계정탈퇴 
### 2. 클라우드 서버 내 Docker & Kubernates <br><br/>
## 🫠 1. AWS 실습, 계정탈퇴 
![image](https://github.com/user-attachments/assets/f064ef3c-a478-4a6d-8245-255a21f1141c)
수업 때 며칠 잠깐 쓴건데도 요금이 발생했다. 오전에는 분명 USD 0.06이었는데 오후가 되니 저 금액으로 올라버렸다.

![image](https://github.com/user-attachments/assets/fbf55a5a-326c-434a-8548-6ad001f66920)
AWS 수업도 끝났고, 요금도 계속 발생하고, 당분간은 AWS를 쓸 생각이 없기 때문에 계정을 삭제했다.

- **AWS 수업 회고**
  - AWS에서 이런 서비스들을 제공한다 위주에 수업이었다보니 그냥 '그렇구나'가 됐고 재미는 없었다.

    그런데 AWS에서 제공하는 서비스가 생각보다 많았기 때문에 잘 사용하면 정말 유용하겠다는 생각은 들었다. 물론 그만큼 과금이 발생하겠지만...
  
<br><br/>

## 🎈 2. 클라우드 서버 내 Docker & Kubernates  
### 2.1 가상 머신(Virtual Machine, VM)
- 물리적으로 존재하는 컴퓨터가 아닌, 다른 컴퓨터가 만들어내는 가상의 컴퓨터
  
- 호스트 OS에 하이퍼바이저(Hypervisor)를 설치하고 그 위에 게스트 OS를 작동시키는 형태로 동작함
  
- 실제 머신의 하드웨어의 기능을 에뮬레이팅함으로써 동작을 지원함
    - 에뮬레이션으로만 가상머신을 만들면 매우 느려지기 때문에 가상 시스템에서 실행되는 명령어 중 원래 시스템에서 그대로 실행해도 무방한 명령어는 그대로 CPU에서 실행시키고, 그렇지 않은 명령어는 에뮬레이션 함
        - 에뮬레이션 : 모든 것을 소프트웨어적으로 구현
        - 가상화 : 주요 부품의 구현에서 하드웨어적 지원을 받음
<br><br/>

### 2.2 컨테이너(Container)
- 컨테이너는 코드(code)와 모든 관련있는 라이브러리의 종속성(dependencies)을 포함하여 만든 표준 단위

- 프로그램(application)을 동작할 수 있도록 만든 환경에서 빠르고 신뢰성 있게 다른 환경으로 쉽게 이식할 수 있게 만든 것

- 호스트 OS의 커널을 공유하면서 분리된 프로세스로서 실행해 마치 가상머신이 움직이는 것처럼 보이게 하는 기술

- 호스트 OS에 컨테이너 런타임을 올리고 그 위에 프로세스로서 컨테이너를 동작시킴
 
- 컨테이너의 실체는 단순한 프로세스이므로 가상 머신에 비해 매우 가볍고 빠르게 동작할 수 있음

- 가상머신 방식 vs. 컨테이너 방식
<br><img src="https://github.com/aidalabs/Lectures/blob/main/LectureFiles/images/MLO003_Container_001.png?raw=true"><br>
<br><br/>

### 2.3 도커(Docker)
#### 2.3.1 개요와 역사
- 컨테이너라는 경량 단위로 애플리케이션을 실행하는 기능을 제공하는 플랫폼
  
- 컨테이너를 동작시키기 위한 엔진의 하나

- 2013년 3월 파이콘(PyCon)에서 닷클라우드(도커의 전신)에 의해 발표, 공개됨

#### 2.3.2 도커가 빠르게 확산된 이유
컨테이너 기술 자체는 새로운 기술이 아니었으나 도커는 다음의 이유로 단기간에 개발자들의 지지를 얻음
  
**① 컨테이너 관리 방식**
  - 도커에서는 Dockerfile이라는 정의 파일을 작성하여 동일한 컨테이너 이미지를 간단히 만들 수 있음
  - 이는 IaC(Infrastructure as Code)를 구현하는데 매우 적합한 소프트웨어의 형태임
  - 또한 컨테이너의 이미지에는 애플리케이션과 그 실행 환경 설정이 포함되어 있기 때문에 도커 엔진만 설치되어 있다면 그 애플리케이션의 동작이 보장되는 장점도 있음

**② 에코시스템**
  - 컨테이너 이미지를 저장, 공유하기 위한 에코 시스템이 초기부터 준비되어 있었음
  - 생성한 컨테이너 이미지는 각 환경에 확실히 배포할 수 있어야 의미가 있으며, 도커에서는 도커 허브(Docker Hub)라는 컨테이너 이미지를 저장, 공유할 수 있는 컨테이너 저장소(Repository)가 제공됨
  - docker push/pull 명령으로 간단히 도커 허브에 컨테이너 이미지를 전송하거나 다운로드 할 수 있음
  - 이를 통해 애플리케이션을 배포할 때 환경 설정 차이로 인해 발생하기 쉬운 문제를 해결할 수 있음
  - 즉, 개발 환경에서 스테이징 환경, 서비스 환경으로 동일한 컨테이너 이미지를 배포할 수 있으므로 테스트를 거친 컨테이너 이미지를 서비스 환경에 안정적으로 배포할 수 있음
  <br><br>
- 동일한 컨테이너 이미지를 배포함으로써 애플리케이션 실행 보장
 <img src="https://github.com/aidalabs/Lectures/blob/main/LectureFiles/images/MLO003_Docker_001.png?raw=true">

#### 2.3.3 도커의 구성 요소
- 도커파일(Dockerfile)
    - 운영체제, 언어, 환경 변수, 파일 위치, 네트워크 포트, 이를 실행하는 데 필요한 여타 컴포넌트를 포함하는 도커 이미지를 구축할 수 있는 일련의 명령을 제공하는 텍스트 파일
    - 각 도커 컨테이너는 도커파일과 함께 시작함

- 도커 이미지(Docker image, Container image)
    - VM 환경의 스냅샷과 유사하며 이식 가능하고 읽기 전용의 실행 파일
    - 컨테이너를 생성하기 위한 명령, 그리고 컨테이너가 어떤 소프트웨어 컴포넌트를 어떻게 실행할 것인가에 대한 내역이 담겨 있음

- 도커 실행 유틸리티(Docker run utility)
    - 컨테이너를 시작하는 명령
    - 각 컨테이너는 이미지 인스턴스이고, 동일 이미지의 다수의 인스턴스가 동시에 실행될 수 있음

- 도커 허브(Docker Hub):
    - 테이너 이미지가 저장되고 공유되고 관리될 수 있는 저장소(Repository)
    - 컨테이너에 특화된 깃허브 도커 버전이라고 생각할 수 있음

- 도커 엔진(Docker Engine)
    - 도커의 핵심
    - 컨테이너를 생성하고 실행하는 클라이언트-서버 기술이다. 도커 엔진은 컨테이너를 관리하는 이른바 ‘도커 대몬(Docker daemon)’이라는 장시간 실행되는 대몬 프로세스, 도커 대몬과 프로그램 사이의 통신을 담당하는 API, 명령줄 인터페이스를 포함한다.

- 도커 컴포즈(Docker Compose)
    - YAML 파일을 이용하는 명령줄 도구이며 멀티 컨테이너 도커 애플리케이션을 정의하고 실행함
    - 이에 의해 사용자는 사용자의 구성 환경으로부터 모든 서비스를 생성하고 시작하고 정지하고 재구축할 수 있으며, 모든 실행 서비스의 현황 및 로그 출력을 열람할 수 있음

- 도커 데스크톱(Docker Desktop)
    - 위에서 다룬 제반 컴포넌트는 도커 데스크톱 애플리케이션으로 래핑 됨
    - 이는 컨테이너화 된 애플리케이션과 마이크로서비스를 구축하고 공유하는 사용자 친화적 방식을 제공함

#### 2.3.4 도커의 장점
- 도커 컨테이너는 이전의 방법보다 더 쉽게 조립하고, 유지관리하고, 이동시킬 수 있는 애플리케이션 제작 방법을 제공
  
- 소프트웨어 개발자에게 다음과 같은 혜택을 제공
    - 최소의 요소로 구성되어 높은 이식성을 가짐
        - 도커는 애플리케이션과 이의 환경을 격리시킴으로써 이들을 정연하고 최소한으로 유지할 수 있게 해줌
        - 이에 의해 미시적 제어와 이식성이 높아짐
    - 컴포저블(composability) 특성 보유
        - 컨테이너는 개발자가 애플리케이션의 구성 요소를 쉽게 호환되는 부분들로 된 모듈식 유닛으로 더 쉽게 조합할 수 있게 해줌
        - 이는 개발 주기, 기능 배포, 버그 수정의 속도를 높일 수 있음
    - 오케스트레이션과 스케일링 용이
        - 컨테이너는 경량이기 때문에 개발자는 많은 수의 컨테이너를 시작해 서비스 스케일링을 향상시킬 수 있음
        - 컨테이너 클러스터는 당연히 오케스트레이션이 필요하고 여기서 **쿠버네티스**가 등장

#### 2.3.5 도커의 단점
- 컨테이너는 수많은 문제를 해결하지만 개발자가 가진 모든 난제를 해결하지는 못함

- 도커 컨테이너는 VM이 아니다.
    - VM과 달리 컨테이너는 호스트 운영체제 리소스의 제어된 부분을 이용함
    - 따라서 요소들이 VM 수준으로 엄격히 격리되지 않음

- 도커 컨테이너는 베어-메탈 속도를 제공하지 않는다.
    - 컨테이너는 VM보다 더 경량이고 베어 메탈에 더 가까움
    - 그러나 이는 성능 오버헤드를 초래함
    - 워크로드가 베어-메탈 속도를 요구한다면 컨테이너는 이에 근접한 속도를 제공하지만 동일한 속도는 아님

- 도커 컨테이너는 스테이트리스(stateless)이며, 불변적(immutable)이다.
    - 컨테이너는 해당 콘텐츠를 담은 이미지로부터 시작되고 실행됨
    - 이미지는 기본적으로 일단 생성되면 변경되지 않음
    - 그러나 컨테이너 인스턴스는 일시적(transient)임
    - 인스턴스가 시스템 메모리로부터 제거되면 이는 영원히 사라짐
    - VM처럼 컨테이너를 세션들에 걸쳐 지속시키려면 지속성을 위한 설계가 필요함
<br><br/>

### 2.4 쿠버네티스(Kubernetes)
#### 2.4.1 개요
- 2014년 구글에서 발표한 오케스트레이션 도구
  
- 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식할 수 있고, 확장 가능한 오픈소스 플랫폼

- 구글이 자사 서비스를 호스트하기 위해 개발한 보그(Borg)라는 오케스트레이션 도구가 기원임

- 2015년 7월 21일, 버전 1.0을 발표함과 동시에 리눅스 파운데이션과 공동으로 클라우드 네이티브 컴퓨팅 파운데이션(Cloud Native Computinf Foundation, CNCF)을 설립하고 쿠버네티스를 CNCF에 기증함

- 이후 쿠버네티스를 중심으로 한 에코시스템이 형성되면서 현재는 컨테이너 오케스트레이션 도구의 사실상 표준의 위치를 차지함

#### 2.4.2 쿠버네티스의 동작
- 데이터 플레인이라고 불리는 서버를 여러 대 실행시켜 그 위에 가상 오케스트레이션 계층을 구축하고 거기에서 컨테이너가 동작함

- 컨테이너 이용자는 이를 통해 컨테이너 그룹을 하나의 큰 머신 리소스로 볼 수 있게 되어 인프라를 추상화할 수 있음

- 어떤 가상 머신에서 어느 정도의 컨테이너를 동작시킬지를 관리하거나 새로운 컨테이너를 배포할 때 어떤 가상 머신에 배포하면 좋을지 등을 자동으로 판단함

- 장애가 발생한 컨테이너를 정지시키고 재시작하는 구조를 가짐

- 이러한 기능은 컨트롤 플레인이라는 마스터 노드 그룹에서 구현됨

- 이 외에도 수많은 기능으로 구성됨(쿠버네티스가 어려워지는 이유)

#### 2.4.3 쿠버네티스의 구성
<img src="https://github.com/aidalabs/Lectures/blob/main/LectureFiles/images/MLO003_Cubernetes_001.png?raw=true">

#### 2.4.4 쿠버네티스가 할 수 있는 일
- 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공

- 애플리케이션의 확장과 장애 조치를 처리하고, 배포 패턴 등을 제공
  
- 서비스 디스커버리와 로드 밸런싱
    - 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있음
    - 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있음

- 스토리지 오케스트레이션
    - 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있음

- 자동화된 롤아웃과 롤백
    - 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있음
    - 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있음
        - 예: 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있음

- 자동화된 빈 패킹(bin packing)
    - 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공함
    - 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시 → 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해줌

- 자동화된 복구(self-healing)
    - 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않음

- 시크릿과 구성 관리
    - 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리할 수 있음
    - 컨테이너 이미지를 재구성하지 않고, 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트할 수 있음
<br><br/>

















