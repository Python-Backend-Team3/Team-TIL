# 📝 2024.09.27 회고 📝
#### 1. 수업 내용 복습정리
#### 2. 백준

---------------------------------


## S3사용하기
- 어제 코드에서 맨 아래 암호키 추가를 하게 되면 로컬사용이 가능한것같다(나는 성공하지 못함..)
```
import io
import os
import uuid

import boto3
from boto3.s3.transfer import S3UploadFailedError
from botocore.exceptions import ClientError


def do_scenario(s3_resource):
    print("-" * 88)
    print("Welcome to the Amazon S3 getting started demo!")
    print("-" * 88)

    bucket_name = f"doc-example-bucket-{uuid.uuid4()}"
    bucket = s3_resource.Bucket(bucket_name)
    try:
        bucket.create(
            CreateBucketConfiguration={
                "LocationConstraint": s3_resource.meta.client.meta.region_name
            }
        )
        print(f"Created demo bucket named {bucket.name}.")
    except ClientError as err:
        print(f"Tried and failed to create demo bucket {bucket_name}.")
        print(f"\t{err.response['Error']['Code']}:{err.response['Error']['Message']}")
        print(f"\nCan't continue the demo without a bucket!")
        return

    file_name = None
    while file_name is None:
        file_name = input("\nEnter a file you want to upload to your bucket: ")
        if not os.path.exists(file_name):
            print(f"Couldn't find file {file_name}. Are you sure it exists?")
            file_name = None

    obj = bucket.Object(os.path.basename(file_name))
    try:
        obj.upload_file(file_name)
        print(
            f"Uploaded file {file_name} into bucket {bucket.name} with key {obj.key}."
        )
    except S3UploadFailedError as err:
        print(f"Couldn't upload file {file_name} to {bucket.name}.")
        print(f"\t{err}")

    answer = input(f"\nDo you want to download {obj.key} into memory (y/n)? ")
    if answer.lower() == "y":
        data = io.BytesIO()
        try:
            obj.download_fileobj(data)
            data.seek(0)
            print(f"Got your object. Here are the first 20 bytes:\n")
            print(f"\t{data.read(20)}")
        except ClientError as err:
            print(f"Couldn't download {obj.key}.")
            print(
                f"\t{err.response['Error']['Code']}:{err.response['Error']['Message']}"
            )

    answer = input(
        f"\nDo you want to copy {obj.key} to a subfolder in your bucket (y/n)? "
    )
    if answer.lower() == "y":
        dest_obj = bucket.Object(f"demo-folder/{obj.key}")
        try:
            dest_obj.copy({"Bucket": bucket.name, "Key": obj.key})
            print(f"Copied {obj.key} to {dest_obj.key}.")
        except ClientError as err:
            print(f"Couldn't copy {obj.key} to {dest_obj.key}.")
            print(
                f"\t{err.response['Error']['Code']}:{err.response['Error']['Message']}"
            )

    print("\nYour bucket contains the following objects:")
    try:
        for o in bucket.objects.all():
            print(f"\t{o.key}")
    except ClientError as err:
        print(f"Couldn't list the objects in bucket {bucket.name}.")
        print(f"\t{err.response['Error']['Code']}:{err.response['Error']['Message']}")

    answer = input(
        "\nDo you want to delete all of the objects as well as the bucket (y/n)? "
    )
    if answer.lower() == "y":
        try:
            bucket.objects.delete()
            bucket.delete()
            print(f"Emptied and deleted bucket {bucket.name}.\n")
        except ClientError as err:
            print(f"Couldn't empty and delete bucket {bucket.name}.")
            print(
                f"\t{err.response['Error']['Code']}:{err.response['Error']['Message']}"
            )

    print("Thanks for watching!")
    print("-" * 88)


# if __name__ == "__main__":
#     do_scenario(boto3.resource("s3"))

if __name__ == "__main__":

    session = boto3.Session(
        aws_access_key_id = "**********",
        aws_secret_access_key = "*****************************************",
        region_name = "ap-northeast-2"
    )
    do_scenario(session.resource('s3'))
```
- 암호키랑 리전네임(서울)을 넣어주니까 동작되는 것을 확인
![image](https://github.com/user-attachments/assets/d581415a-cd39-4e83-b6c2-27032de57ed4)

## DynamoDB 사용
- https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/programming-with-python.html
- 클라이언트 인터페이스를 사용하여 항목 삽입하기

```
- dynamodb에서 테이블을 생성해서 진행(test 라는 테이블)


import boto3

dynamodb = boto3.client('dynamodb')

dynamodb.put_item(
    TableName='YourTableName', # 우리의 경우 test
    Item={
        'pk': {'S': 'id#1'},
        'sk': {'S': 'cart#123'},
        'name': {'S': 'SomeName'},
        'inventory': {'N': '500'},
        # ... more attributes ...
    }
)
```
![image](https://github.com/user-attachments/assets/f199b04a-58c4-4fa9-a851-fb9629948506)
![image](https://github.com/user-attachments/assets/9a80e6c0-8579-47f3-8e9c-48c6d0542cc3)
------------
- 리소스 인터페이스를 사용하여 항목 삽입하기
```
- 이번에는 ubuntu에서 nano를 사용해서 에디터를 대신함
- 이번에는 클라이언트가 아닌 테이블 리소스에서 가져와 그 안에 집어 넣는 것으로 진행함
import boto3

dynamodb = boto3.resource('dynamodb')

table = dynamodb.Table('YourTableName') # 우리의 경우 test

table.put_item(
    Item={
        'pk': 'id#1',
        'sk': 'cart#123',
        'name': 'SomeName',
        'inventory': 500,
        # ... more attributes ...
    }
)
```
![image](https://github.com/user-attachments/assets/5ad9c396-51e3-4b3d-af65-53c58c5ef3fa)
- nano의 경우 ctrl 5를 눌러야 저장이 됨
![image](https://github.com/user-attachments/assets/8cfbfe9e-d888-4406-9c7b-7c36fddd10df)
- 위와같이 저장된것을 확인
-------------
- 함께 제공된 및 클래스를 사용하여 일반 JSON과 DynamoDB JSON 간에 변환하기
```
def dynamo_to_python(dynamo_object: dict) -> dict:
    deserializer = TypeDeserializer()
    return {
        k: deserializer.deserialize(v)
        for k, v in dynamo_object.items()
    }

def python_to_dynamo(python_object: dict) -> dict:
    serializer = TypeSerializer()
    return {
        k: serializer.serialize(v)
        for k, v in python_object.items()
    }
```
-----------
- 클라이언트 인터페이스를 사용하여 쿼리 수행하기
```
import boto3

client = boto3.client('dynamodb')

# Construct the query
response = client.query(
    TableName='YourTableName',
    KeyConditionExpression='pk = :pk_val AND begins_with(sk, :sk_val)',
    FilterExpression='#name = :name_val',
    ExpressionAttributeValues={
        ':pk_val': {'S': 'id#1'},
        ':sk_val': {'S': 'cart#'},
        ':name_val': {'S': 'SomeName'},
    },
    ExpressionAttributeNames={
        '#name': 'name',
    }
)
```
- 위 내용도 동일하게 nano로 진행
![image](https://github.com/user-attachments/assets/96346873-ff85-4460-82cb-52f78f854f5c)
![image](https://github.com/user-attachments/assets/6da75ffa-69d6-4137-93e1-d4d9c2fdab32)
-------
- 리소스 인터페이스를 사용하여 쿼리 수행하기
```
import boto3
from boto3.dynamodb.conditions import Key, Attr

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('YourTableName')

response = table.query(
    KeyConditionExpression=Key('pk').eq('id#1') & Key('sk').begins_with('cart#'),
    FilterExpression=Attr('name').eq('SomeName')
)
```
![image](https://github.com/user-attachments/assets/5d539d0f-1d43-4970-94c4-4eb80c82c8dd)
- 위 다른것들이랑 형태가 조금 다른것을 확인함
------------
- 클라이언트 인터페이스를 사용하여 테이블의 대략적인 크기 얻기
```
import boto3

dynamodb = boto3.client('dynamodb')

response = dynamodb.describe_table(TableName='YourTableName')
size = response['Table']['TableSizeBytes']

print(f"Table size: {size}")
```
![image](https://github.com/user-attachments/assets/731712da-1a02-47b7-9932-855d5c6d73a2)
--------

- 리소스 인터페이스를 사용하여 테이블의 대략적인 크기 얻기
```
import boto3

dynamodb = boto3.resource('dynamodb')

table = dynamodb.Table('YourTableName')
size = table.table_size_bytes

print(f"Table size: {size}")
```
![image](https://github.com/user-attachments/assets/825bdd9c-4cd4-4b54-89a8-eb21771489e6)
![image](https://github.com/user-attachments/assets/04aeb72a-505f-434a-9fe1-bf1ab4ffa644)

-----------

### Polly 사용하기
- https://docs.aws.amazon.com/ko_kr/polly/latest/dg/get-started-what-next.html
```
from boto3 import Session
from botocore.exceptions import BotoCoreError, ClientError
from contextlib import closing
import os
import sys
import subprocess
from tempfile import gettempdir

# AWS 자격 증명 파일 (~/.aws/credentials)의 [관리자] 섹션에 정의 된
# 자격 증명 및 영역을 사용하여 클라이언트를 만듦(~/.aws/credentials).
session = Session(profile_name="adminuser")
polly = session.client("polly")

try:
    # 음성 합성 요청
    response = polly.synthesize_speech(Text="Hello world!", OutputFormat="mp3", VoiceId="Joanna")

except (BotoCoreError, ClientError) as error:
    # 서비스는 오류를 반환하고 종료
    print(error)
    sys.exit(-1)

# 응답으로부터 오디오 스트림에 액세스
if "AudioStream" in response:
    # 참고 : 서비스가 병렬 연결 수에 조절되기 때문에 스트림을 닫는 것이 중요함.
    # 여기서는 contextLib.closing을 사용하여 스트림 객체의 닫기 메소드가 명령문의
    # 범위 끝에 자동으로 호출되도록 함.
    with closing(response["AudioStream"]) as stream:
        output = os.path.join(gettempdir(), "speech.mp3")

        try:
        # 바이너리 스트림으로 출력을 쓰기위한 파일 열기
            with open(output, "wb") as file:
                file.write(stream.read())
        except IOError as error:
            # 파일에 쓸 수 없었음. 종료
            print(error)
            sys.exit(-1)

else:
    # 응답에 오디오 데이터가 포함되어 있지 않았음. 종료
    print("Could not stream audio")
    sys.exit(-1)

# 플랫폼의 기본 플레이어를 사용하여 오디오 재생
# 윈도우의 경우
if sys.platform == "win32":
    os.startfile(output)
else:
    # MacOS 및 Linux의 경우(Darwin = Mac, XDG-OPEN = Linux)
    opener = "open" if sys.platform == "darwin" else "xdg-open"
    subprocess.call([opener, output])
```
- 리눅스 쪽에서는 재생은 안되지만 파일은 생성됨
- 권한을 만들어서 진행하는것이 좋아보임

## 클라우드 서버 내 Docker & Kubernates 

#### 컨테이너 기술 보급과 쿠버네티스

##### 가상머신
- 물리적으로 존재하는 컴퓨터가 아닌, 다른 컴퓨터가 만들어내는 가상의 컴퓨터
- 호스트 OS에 하이퍼바이저를 설치하고 그 위에 게스트 OS를 작동시키는 형태로 동작
- 실제 머신의 하드웨어의 기능을 에뮬레이팅함으로써 동작을 지원
    - 에뮬레이션으로만 가상머신을 만들면 매우 느려지기 때문에 가상 시스템에서 실행되는 명령어 중 원래 시스템에서 그대로 실행해도 무방한 명령어는 땡겨와서 사용(그대로 CPU에서 실행), 그렇지 않은 명령어만 에뮬레이션함
        - 에뮬레이션 : 모든 것을 소프트웨어적으로 구현
        - 가상화 : 주요 부품의 구현에서 하드웨어적 지원을 받음
     
##### 컨테이너
- 컨테이너는 코드와 모든 관련이 있는 라이브러리의 종속성을 포함해서 만든 표준 단위
- 프로그램을 동작할 수 있도록 만든 환경에서 빠르고 신뢰성 있게 다른 환경으로 쉽게 이식할 수 있게 만든 것
- 호스트 OS의 커널을 공유하면서 분리된 프로레스로서 실행해 마치 가상머신이 움직이는 것처럼 보이게 하는 기술이다.
- 호스트 OS에 컨테이너 런타임을 올리고 그 위에 프로세스로서 컨테이너를 동작시킨다.
- 컨테이너의 실체는 단순한 프로세스이므로 가상 머신에 비해 매우 가볍고 빠르게 동작할 수 있다.
- 가상머신 vs 컨테이너 방식
![Uploading image.png…]()

##### 도커
- 개요와 역사
- 컨테이너라는 경량 단위로 애플리케이션을 실행하는 기능을 제공하는 플랫폼
- 컨테이너를 동작시키기 위한 엔진의 하나
- 2013년 3월 파이콘(PyCon)에서 닷클라우드(도커의 전신)에 의해 발표, 공개됨
    - 2008년 솔로몬 하익스가 프랑스 파리에서 닷클라우드(DotCloud)라는 이름으로 설립
    - 원래 서비스 플랫폼(platform as a service, PaaS)로서 시작
    - 이후 2013년 플랫폼이 실행되는 기저의 소프트웨어 컨테이너를 보편화하는 것으로 초점이 변화함















```
```

```
```

```
```
