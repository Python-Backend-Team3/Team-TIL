# 📝 2024.09.19 회고 📝
#### 1. 수업 내용 복습정리
#### 2. 오류
#### 3. 백준

---------------------------------

- 요구사항 분석을 간략하게 하더라도 TDD(Test-Driven Development, 테스트 주도 개발)는 여전히 가능하다.
- TDD는 구체적인 요구사항 분석 없이도 충분히 효과적으로 사용할 수 있다.
- TDD는 테스트 케이스를 먼저 작성한 후 그 테스트를 통과하기 위한 코드를 구현하는 방식이므로, 기능을 세분화하여 테스트하는 것이 핵심이다.
- 따라서 TDD를 사용하면, 요구사항을 분석하는 과정에서 완벽하지 않더라도, 기능을 구현해 나가며 필요한 테스트 케이스를 점진적으로 추가하고 개선할 수 있다.
- 이는 개발 초기의 불확실성을 줄이는 동시에, 코드 품질과 유지보수성을 높이는 데 기여할 수 있다.

## TDD 요약
### 테스트 주도 개발(TDD)이란?

- 코드를 작성하기 전에 테스트 케이스를 먼저 작성하는 방식.(개발 과정을 짧은 반복 주기로 나누고, 각 주기마다 사용자의 요구 사항을 테스트 케이스로 변환하여 코드를 개선해 나가는 방식)
- 애자일 방법론 중 하나인 **eXtream Programming(XP)**의 'Test-First' 개념에 기반.
- 짧은 반복 주기를 통해 코드 품질을 높이고 유지보수를 쉽게 만들어 줌.

### 목적
- 코드의 품질을 높임
- 유지보수를 용이하게 함
- 개발자의 생산성을 높이는데 도움을 줌
- 설계 오류를 초기에 발견, 수정할 수 있게 지원
- 개발 과정에서의 오류와 리스크를 줄이기 위해 고안됨

### TDD의 핵심 단계
- 실패하는 테스트 작성: 요구사항을 테스트로 정의.
- 테스트를 통과하는 코드 작성: 최소한의 코드를 작성하여 테스트 통과.
- 리팩토링: 코드 품질을 개선하고 중복된 코드 제거.
- 점진적 코드 개선: 위 단계를 반복하여 기능을 확장하고 개선.

### 장점
- 빠른 피드백을 제공하여 버그를 조기 발견.
- 유지보수가 용이하고, 코드 품질이 높아짐.
- 개발 이력을 기록하여 과거의 의사결정을 상기 가능.

### 단점
- 초기 학습이 필요하고, 생산성 저하에 대한 우려.
- 초기 투자 비용과 시간이 더 들 수 있음.
- SI 프로젝트 등에서는 납기일 준수가 중요하여 잘 사용되지 않음.

#### TDD의 효과
- 디버깅 시간 단축: 코드에 문제가 발생할 때, 어느 부분에서 발생했는지 쉽게 파악 가능.
- 빠른 피드백: 기능 단위로 테스트를 진행하므로 빠르게 피드백 제공.
- 재설계 시간 단축: 개발 과정에서의 불필요한 설계 변경을 줄여줌.
- 오버 엔지니어링 방지: 테스트를 통과하는 최소한의 코드만 작성.


## 일반 개발 방식 vs TDD 개발 방식
### 일반 개발 방식 :
##### 개발 주기
- 요구사항 분석 → 설계 → 개발 → 테스트 → 배포
- 개발 초기 단계에서 모든 요구사항을 분석하고 설계를 완료한 후, 코드를 개발, 이후 전체 시스템에 대해 테스트를 수행하고 배포

 ##### 요구사항 분석
 - 요구사항 분석이 초기 단계에서 충분히 이루어지며, 개발 과정에서 큰 변화가 있을 경우 재설계가 필요할 수 있다.
- 요구사항이 명확하지 않으면 초기 설계가 불완전할 수 있고, 이후 수정이 어려워질 수 있다.

##### 코드 작성 및 테스트

- 전체 코드 작성 후, 모든 기능이 구현된 후에 통합 테스트를 수행
- 버그를 발견하면 수정하고, 다시 전체 테스트를 실행하여 검증

##### 리펙토링 및 유지보수
- 초기 설계와 개발이 완료된 후, 유지보수와 리팩토링이 필요할 때 진행
- 코드의 품질 저하가 발생할 수 있으며, 버그 수정 시 전체 시스템에 영향을 미칠 수 있다.

##### 버그 검출 및 수정
- 테스트는 개발 후에 진행되며, 버그는 나중에 발견될 수 있다.
- 버그 발견 시, 모든 기능을 다시 테스트해야 하므로 비용이 증가할 수 있다.

##### 개발 속도 및 비용

-초기 개발 속도가 빠를 수 있으나, 후속 수정과 테스트 비용이 많이 들 수 있다.
- 버그 수정 및 변경이 전체 시스템에 영향을 미칠 수 있다.


### TDD 개발 방식 :
##### 개발 주기
- 디자인(설계) → 테스트 코드 작성 → 코드 개발 → 리팩토링 → 반복
- 개발 과정에서 먼저 테스트 케이스를 작성하고, 이를 기반으로 코드를 개발, 테스트가 통과하면 리팩토링을 통해 코드를 개선하고, 이 과정을 반복

 ##### 요구사항 분석
 - 요구사항을 테스트 케이스 형태로 정의하여, 개발 과정에서 점진적으로 요구사항을 충족시키는 방식
- 설계는 테스트 케이스와 함께 점진적으로 개선되며, 초기 요구사항이 불완전해도 테스트를 통해 기능을 검증하고 수정할 수 있다.

##### 코드 작성 및 테스트

- 테스트 케이스를 작성한 후, 이를 통과시키기 위한 최소한의 코드를 작성
- 각 기능이 개발될 때마다 테스트를 통해 검증하며, 테스트를 통과한 후 코드 리팩토링을 수행

##### 리펙토링 및 유지보수
- 코드 작성 후 바로 리팩토링을 수행하여 코드의 품질을 유지
- 테스트가 있어 코드 변경 시 기존 기능의 정상 동작을 확인할 수 있어 유지보수가 용이

##### 버그 검출 및 수정
- 테스트를 먼저 작성하므로, 버그를 조기에 발견할 수 있다.
- 기능 단위로 검증하며, 테스트 케이스가 자동화되어 있어 버그 수정이 효율적이다.

##### 개발 속도 및 비용

- 초기 비용과 학습 곡선이 있을 수 있지만, 장기적으로 유지보수와 코드 품질이 개선된다.
- 개발 초기 단계에서 더 많은 시간과 노력이 들 수 있지만, 전체적으로는 더 안정적이고 품질 높은 소프트웨어를 제공할 수 있다.

## 오류
- pytest를 install 하고 실행하는 과정에서 발생한 오류이다.

```
`Windows PowerShell`에서 `pytest`를 실행할때, 테스트할 파일을 지정하지 않으면 프로젝트 폴더 전체에 있는 모든 테스트를 실행하게 된다.
(여기서 몇몇 사람들은 `Lib/site-packages`내에 외부 패키지의 테스트까지 실행이 되어 오류가 발생할 수 있다.
```
- 위와 같은 문제가 발생시에는 해결방법이 2가지 정도 있어 보이는데,
  첫 번째로 `pytest`를 호출할 때 명시적으로 해당 파일을 지정하여 실행하는 방법이다.
```
pytest test_names.py 이런식으로 특정 이름만 지정하면 해당 파일만 지정해서 실행할 수 있다.
```
다른 방법으로는 외부 패키지의 테스트를 제외시키는 것이다. `pytest`가 외부 패키지의 테스트를 실행하지 않도록 설정할 수 있는데, 이를 위해 `pytest.ini` 파일에 아래와 같이 `norecursedirs` 옵션을 추가할 수 있다.
```
[pytest]
norecursedirs = Lib/site-packages
```
이 설정을 통해서 `Lib/site-packages` 디렉토리의 테스트 파일을 무시하도록 할 수 있다.

## 백준
파이썬에서의 자료구조
여러개의 데이터가 묶여있는 자료형을 컨테이너 자료형이라함. 이러한 컨테이너 자료형의 데이터 구조를 자료 구조.

- 리스트 :순서가 있는 가변적인 데이터 구조, 리스트는 같은 타입이 아니어도 다양한 데이터 타입의 요소를 포함할 수 있으며, 요소를 수정하거나 삭제할 수 있음 []
- 튜플 : 순서가 있는 불변의 데이터 구조, 한 번 정의되면 요소를 변경하거나 삭제할 수 없습니다. 다양한 데이터 타입을 포함할 수 있음 ()
- 딕셔너리 : 키와 값의 쌍으로 구성된 데이터 구조, 각 키는 유일해야 하며, 키를 통해 해당 값을 빠르게 조회할 수 있으며, 키와 값 모두가 변할 수 있음 {}
- 셋트 : 순서가 없고, 중복된 데이터가 허용되지 않는 데이터 구조, 중복된 요소를 추가하려고 하면 자동으로 제거됨 {}

###### 리스트
- 배열과 같이 여러 개의 데이터를 나열한 자료 구조
- [] 를 이용해서 선언, 데이터 아이템 구분은 ',' comma를 이용
- 데이터 타입 문자열, 정수형, 실수형 모두 가능함

###### 인덱스
- 리스트 아이템은 인덱스를 이용해서 조회 가능함
- 존재하지 않는 잘못된 인덱스를 사용하면 오류남

###### enumerate함수 ( 이번 문제를 풀면서 새로 공부한 내용 )
- `enumerate()` 함수는 Python에서 반복 가능한 객체(iterable)와 함께 인덱스와 값을 동시에 가져오는 데 유용한 함수
- 리스트, 튜플, 문자열 등의 반복 가능한 객체를 순회하면서 각 항목의 인덱스와 값을 동시에 처리할 수 있다.

- 문법은 이런식으로 쓰이며 `enumerate(iterable, start=0)`  `iterable`: 반복 가능한 객체 (예: 리스트, 튜플, 문자열 등)
 `start`: 인덱스 시작값 (기본값은 0)을 넣는다.
- 반복 가능한 객체를 순회하면서 각 항목의 인덱스와 값을 튜플 형태로 반환하는 것이다.

```
# 리스트를 사용할때
fruits = ["apple", "banana", "cherry"]

for index, fruit in enumerate(fruits):
    print(f"Index {index}: {fruit}")
# 출력
Index 0: apple
Index 1: banana
Index 2: cherry

# 문자열을 사용할 때
word = "hello"

for index, char in enumerate(word):
    print(f"Index {index}: {char}")

# 출력
Index 0: h
Index 1: e
Index 2: l
Index 3: l
Index 4: o

# 시작 인덱스 지정시
animals = ["dog", "cat", "rabbit"]

for index, animal in enumerate(animals, start=1):
    print(f"Animal {index}: {animal}")

# 출력
Animal 1: dog
Animal 2: cat
Animal 3: rabbit

```

### 백준 2745 진법 변환 문제
- 이 문제에서 enumerate()를 사용하여 역순으로 처리한 문자열 N의 각 문자와 그 인덱스를 사용하게 코드를 구성했다.
- enumerate()는 문자와 해당 문자의 인덱스를 동시에 제공하고 있으므로, 이를 활용해서 다음과 같이 계산했다.

```
N, b = input().split()
ary = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"

N = N[::-1]  # 문자열을 역순으로 변환
result = 0

for i, n in enumerate(N):
    result += (int(b) ** i) * ary.index(n)  # 각 자리의 값을 계산하여 result에 더함

print(result)
```
###### 내가 생각한 순서
- N을 역순으로 변환해서 enumerate()를 사용해 각 문자의 인덱스와 값을 동시에 가져온다음 b진법을 이용해 10진법으로 변환해 result에 출력

- 여기서 ary.index(n) 는 문자를 핻강 숫자로 변환시키는 것이고, (int(b) ** i)는 현재 자리의 위치에 해당하는 b의 거듭제곱을 계산


![image](https://github.com/user-attachments/assets/4bf99fc8-0cff-4cb9-947e-3f002abda1e4)
- 이 과정을 통해 b진법으로 표현된 수를 10진법으로 변환한 것이다.
