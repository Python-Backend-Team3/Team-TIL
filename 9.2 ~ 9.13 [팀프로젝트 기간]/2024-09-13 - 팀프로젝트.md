# 🏪 1차 팀프로젝트 마무리 정리 🏪

## 🩷혜지 

### 1. 코드 작성하면서 어려웠던 기능
- 장바구니에 있는 상품을 주문으로 생성하는 구현이 어려웠음
  
  carts와 orders 부분만 있었을 때는 오류가 나지 않았는데 reviews와 합해지면서 오류가 발생하게 됨

  리뷰에서는 로그인이 된 사용자, 물건을 구매한 사용자만이 리뷰를 작성할 수 있도록 구현하였으나 나는 이점을 고려하지 않고 orders 기능을 구현하여 발생한 오류였음

  현재 요청을 보낸 사용자가 로그인이 된 상태인지 확인하기 위해 order_create 함수에 사용자 정보를 설정하는 order.user = request.user 코드를 추가하여 에러를 해결함
<br><br/>

### 2. 구현하지 못한 기능
- 메인 페이지에서 <담기> 버튼을 누르면 장바구니에 해당 상품이 담기게 하는 기능
  - 자바스크립트를 이용하면 쉽게 구현 가능한 기능으로 html만으로 해보려했으나 오류 때문에 포기한 상황이다
<br><br/>

### 3. 3차때는 어떤 기능을 구현할 것인지
- 구매 이력 조회 : 사용자가 주문하고 내가 주문한 내역을 볼 수 있는 창을 볼 수 있게 구현할 예정이다. 이건 마이페이지에서 볼 수 있으면 좋을 것 같다.

- 메인 페이지에서 <담기> 버튼을 누르면 장바구니에 해당 상품이 담기게 하기

- <주문요청하기> 버튼을 누르면 배송상태가 delivered로 변경 : 배송상태가 delivered로 바뀌어야 리뷰를 작성할 수 있다. 현재는 이 부분이 구현되지 않아 admin 페이지에 들어가서 직접 바꿔주어야한다.
  이 부분을 자동으로 바뀔 수 있게 구현하여 배송이 완료되면 리뷰를 작성할 수 있게 구현할 예정이다.
 
- 찜하기 기능 추가 : 메인페이지에 하트 아이콘이 있는데 이 아이콘을 누르면 사용자가 찜하기 한 상품 목록을 볼 수 있게 구현할 예정이다.

- 주문내역에 사용자의 정보가 자동으로 들어갈 수 있게 구현하고싶다. 
<br><br/>

### 4. 느낀점
- 작업이 한 사람에게 몰리지 않게 적절한 분업의 필요성을 느꼈다.

  각자의 기능 구현이 완벽하지 않더라도 최대한 빠르게 진행한 후에 서로의 코드를 공유하는 것이 오히려 효율적이겠다는 생각이 들었다.
  
  어차피 우리는 배우는 단계라 구현이 완벽하지 않을텐데 계속 붙잡고 있어봤자 시간만 지체될 뿐이다.
  
  개인적으로는 자바 스크립트를 공부해서 3차때는 원하는 기능, 다양한 기능을 추가하면 좋을 것 같다고 생각했고, 내가 아는 것이 많으면 팀원들에게 많은 도움을 주었을 텐데 그러지 못한것 같아 미안했다.
<br><br/>

## 💛향은 

### 1. 코드 작성하면서 어려웠던 기능
- Category 기능 구현이 어려웠음

   처음에는 프로젝트 초기 단계에서 빠르게 개발을 진행하고 데이터베이스 구조를 단순화 시키기 위해 CharField 또는 ChoiceField를 사용하려 했음
  
   그러나 프로젝트가 커지면서 확장성과 데이터 관리의 어려움이 예상되어 독립된 Category 모델을 사용하는 게 더 적합하다고 결론 내림

   하지만, 카테고리 필드를 Product모델에 추가하면서 기존에 등록된 Product 데이터와의 호환성 문제를 겪음

   Product 모델에 새로운 Category 필드를 추가했지만, 기존에 저장된 제품 데이터에는 이 필드와 연결된 Category 객체가 없었기 때문에 외래 키 제약 조건을 위반하는 오류가 발생함

   이 문제를 해결하기 위해 우선 기존 제품 데이터에 대해 기본 카테고리를 설정해주고, 새롭게 정의된 Category 객체와 기존 데이터를 연결하는 마이그레이션 작업을 수행함

   마이그레이션 과정에서 기존 데이터의 무결성을 유지하면서 새로운 필드를 적용하는 것이 어려웠지만 여러 시도 끝에 다행히 잘 구현됨
<br><br/>

### 2. 구현하지 못한 기능
- 구매 이력 조회 기능을 구현하지 못했음
- 기본적인 데이터 모델과 프로젝트 연결은 완료했으나 데이터를 적절히 불러오는 로직과 템플릿에서 해당 데이터를 표시하는 방식에 여러 이슈가 발생했음
- 또한, 각 구매자의 주문 내역을 효율적으로 필터링하는 부분에 문제가 있었는데, 이 부분은 3차 프로젝트에서 보완할 계획임
<br><br/>

### 3. 3차때는 어떤 기능을 구현할 것인지
- 우선 구매 이력 조회 기능을 완료할 계획임, 날짜별로 주문 내역을 필터링 하거나 주문 상태(배송중, 배송완료 등)에 따라 정렬하는 기능을 추가할 예정
- 또한 상품의 상세 페이지에서 좋아요 기능을 통해 사용자 참여를 높이는 기능을 구현하고자 함
<br><br/>

### 4. 느낀점
- 깃허브 연동이 잘 안 되어 코드 및 자료들을 디스코드와 이메일로 주고 받았던게 아쉬웠음. 3차때는 꼭 깃을 활용하여 팀 프로젝트 진행에 도움이 되었음 좋겠음!
<br><br/>

## 💙지웅

### 1. 코드 작성하면서 어려웠던 기능
**1-1. CSS 디자인 조정의 어려움**
- 문제점: 새로운 기능을 추가할 때마다 CSS 디자인이 미세하게 맞지 않아 어려움을 겪었고, 주로 margin과 padding을 통해 조정하였지만 정확한 조정이 어려웠음.
- 해결 방법: 여러 번의 시도 끝에 디자인을 시각적으로 적절하게 맞출 수 있었고, 특히 메인 홈페이지의 배너 슬라이드 기능에서 스크립트를 사용해 3초마다 배너가 넘어가도록 구현함. 하지만, 페이지 크기를 조절할 때 배너 크기가 적절히 조정되지 않는 문제가 여전히 남아있음.

**1-2. 비밀번호 재확인 폼의 입력란 잠금 기능**
- 문제점: 사용자 프로필에 들어가기 전에 비밀번호를 재확인하는 폼에서, 아이디 입력란을 잠그고 싶었음.
- 해결 방법: readonly 속성을 사용하여 입력 필드를 수정할 수 없게 만들었음. readonly 속성은 HTML의 <input> 요소에서 사용자가 값을 수정하지 못하도록 설정하는 속성으로, 보안과 사용자 편의성을 동시에 달성할 수 있었음.
<input type="text" name="id" value="{{ user.username }}" readonly class="readonly-input"><br><br/>

### 2. 구현하려 했으나 해결하지 못한 기능
- 선물특가 타이머 기능
- 타이머 기능을 구현할 때, 새로고침을 해도 타이머가 흐른 시간을 유지하도록 하려고 했으나, 시간이 한번 설정되면 수정이 불가능한 문제가 발생했음. 새로고침 후에도 타이머가 초기화되지 않고 흐른 시간이 유지되도록 하는 것이 어려웠음.
- 현재 상태: 결국 타이머는 새로고침 시마다 시간이 초기화되는 방식으로 설정되었으며, 해당 문제는 3차 프로젝트에서 해결할 계획임.
<br><br/>

### 3. 3차 프로젝트에서 구현하고 싶은 기능
**3-1. 개인 페이지에서 회원 정보 및 비밀번호 수정 기능**
- 사용자들이 자신의 회원 정보를 수정할 수 있는 기능을 추가하고 비밀번호를 변경할 수 있는 기능을 함께 구현하여 사용자 경험을 개선하고, 보안을 강화할 예정.

**3-2. 추천인 코드 및 마일리지 기능**
- 추천인 코드를 통해 새로운 회원 가입 시 추천한 사용자에게 마일리지를 적립해주는 기능을 구현할 예정임. 이 기능을 통해 사용자들의 참여를 독려하고, 마일리지를 활용해 다양한 혜택을 제공할 수 있도록 할 계획임.

**3-3. 홈페이지 검색어 입력 기능 연동**
- 사용자가 검색어를 입력하면 해당 검색어에 맞는 상품이나 정보를 연동하여 제공하는 검색 기능을 추가할 예정임.
<br><br/>

### 4. 느낀점
- 이번 팀 프로젝트를 진행하면서, 협업의 중요성과 각자의 역할 분담이 프로젝트의 성공에 큰 영향을 미친다는 것을 느꼈습니다. 3차 때는 각자 맡은 역할을 더욱 명확하게 분담하고, 코드 리뷰와 소통을 자주 하여 더 효율적인 개발 과정을 만들면 좋겠습니다.
<br><br/>

## 💚덕근

### 1.  구매 확인된 상품에 대해서만 리뷰 작성 가능하게 하기

#### 1-1. 실제 구현된 코드:

```python
  @login_required
  def review_entry_form(request, product_id):
      product = get_object_or_404(Product, id=product_id)
      
      if not Order.objects.filter(user=request.user, items__product=product, status='delivered').exists():
          messages.error(request, "리뷰를 작성할 수 있는 상품이 아닙니다.")
          return redirect('profile_display')
```


#### 1-2. 어려웠던 점:
사용자가 실제로 구매하고 배송 완료된 상품에 대해서만 리뷰를 작성할 수 있도록 제한하는 것이 까다로웠습니다.
주문 정보와 리뷰 시스템의 관계를 정확히 설정해야했습니다.

#### 1-3. 해결 방법:
이 코드에서는 Order 모델을 쿼리하여 사용자가 해당 상품을 구매했고 배송이 완료되었는지 확인합니다. 
조건을 만족하지 않으면 에러 메시지를 표시하고 리뷰 작성을 막습니다.

#### 1-4. 향후 개선 사항: 
시간 문제로 구현된 주문 시스템과의 연동이 아닌 admin에서 직접 주문상태를 delivered를 사용하고 있지만, 3차때 주문 완료 시 자동으로 order 객체가 생성되도록 연동 할 계획입니다. 
<br><br/>

### 2. 리뷰 작성 가능한 상품 필터링

#### 2-1. 실제 구현된 코드:

```python
def get_review_data(user):
    written_reviews = Review.objects.filter(user=user).order_by('-created_at')
    
    eligible_orders = Order.objects.filter(user=user, status='delivered')
    writeable_items = OrderItem.objects.filter(order__in=eligible_orders)
    
    reviewed_products = Review.objects.filter(user=user).values_list('product', flat=True)
    writeable_items = writeable_items.exclude(product__in=reviewed_products)
    
    return {
        'written_reviews': written_reviews,
        'writeable_items': writeable_items,
    }
```

#### 2-2. 어려웠던 점:
주문, 상품, 리뷰 데이터 다른 종류의 데이터를 한꺼번에 연결해서 찾아내야 했습니다. 
사용자가 어떤 상품을 주문했는지, 그 주문의 배송 상태, 리뷰 작성 상태를 동시에 확인하고 연결하는 작업이 어려웠습니다.
이미 리뷰를 작성한 상품을 제외하는 로직을 구현해야 했습니다.

- Django ORM의 효율적인 쿼리 사용
  - values_list(): 쿼리셋의 값을 튜플 형태로 반환한다, 지정된 필드의 값만을 가져온다.
  - exclude: 어떤 조건을 제외 하고 싶을 때

- values_list()를 이용한 특정 필드 데이터 추출 
  ```python
   reviewed_products = Review.objects.filter(user=user).values_list('product', flat=True)
  ```
  
  - values_list('product') = 사용자가 이미 리뷰를 작성한 상품들의 ID 목록을 가져옵니다.
  
  - flat=True 는 리뷰가 작성된 상품의 ID만 리스트 형태로 가져옵니다.
  - flat=True: 이 옵션은 결과를 단일 값의 리스트로 반환하도록 합니다
  - flat=True가 없다면: [(1,), (2,), (3,)] 튜플과 같은 형태로 반환됩니다.
  - flat=True를 사용하면: [1, 2, 3] 같은 형태로 반환됩니다.

- exclude()를 활용한 데이터 필터링
  ```python
   writeable_items = writeable_items.exclude(product__in=reviewed_products)
  ```
  
  - 이 줄은 리뷰 작성 가능한 항목에서 이미 리뷰를 작성한 상품을 제외합니다.
  - exclude(product__in=reviewed_products)는 이미 리뷰를 작성한 상품을 제외시킵니다.


#### 2-3. 해결 방법:
- Django ORM의 필터링과 제외 기능 values_list와 exclude을 활용하여 데이터를 추출했습니다.
- 배송 완료된 주문의 상품 중 아직 리뷰를 작성하지 않은 상품만을 선별했습니다.
<br><br/>



### 3. 리뷰 수정 시 이미지 처리

#### 3-1. 실제 구현된 코드:

```python
@login_required
def edit_review(request, review_id):
    review = get_object_or_404(Review, id=review_id, user=request.user)
    if request.method == 'POST':
        form = ReviewForm(request.POST, request.FILES, instance=review)
        if form.is_valid():
            review = form.save(commit=False)
            if 'image' in request.FILES:
                image_file = request.FILES['image']
                image_content = ContentFile(image_file.read())
                review.image.save(image_file.name, image_content, save=False)
            elif form.cleaned_data['image'] is False:
                review.image = None
            review.save()
            messages.success(request, '리뷰가 성공적으로 수정되었습니다.')
            return redirect('profile_display')
    else:
        form = ReviewForm(instance=review)

    context = {
        'form': form,
        'review': review,
    }
    return render(request, 'reviews/edit_review.html', context)
```

#### 3-2. 어려웠던 점:
기존 이미지 유지, 새 이미지 업로드, 이미지 삭제 등 다양한 상황을 처리해야 했습니다.
파일 업로드와 모델 저장을 동시에 관리해야 했습니다.
리뷰 내용만 변경 시에는 작동되지만 사진을 변경할 경우 에러가 뜨는, 폼 데이터와 파일 데이터를 동시에 처리해야 하는 부분이 어려웠습니다.

- 조건문을 활용한 이미지 처리
  
```python
if 'image' in request.FILES:   # 새 이미지 업로드 처리
elif form.cleaned_data['image'] is False: # 이미지 삭제 처리
```

- 그 외의 경우 기존 이미지 유지

  - 조건문을 활용해 기존 이미지 유지, 새 이미지 업로드, 이미지 삭제등 상황에 대응 할 수 있도록 처리하였습니다.


- ContentFile 클래스 사용
    - 업로드된 파일의 내용을 읽고, 파일 객체를 생성 후 review의 image 필드에 저장합니다.

    - 파일 데이터의 처리 방식이 일반 폼 데이터와 다르기 때문에 파일은 별도의 처리 과정(저장, 삭제 등)이 필요하며, 이 코드에서는 ContentFile을 사용하여 파일 데이터를 처리하고 있습니다.
```python
image_content = ContentFile(image_file.read())
review.image.save(image_file.name, image_content, save=False)
```




- 폼 데이터와 파일 데이터
```python
form = ReviewForm(request.POST, request.FILES, instance=review)
```

- 폼 데이터 (request.POST):
  - 텍스트 입력, 선택 옵션 등 일반적인 폼 필드의 데이터(리뷰 내용, 별점 등)

- 파일 데이터 (request.FILES):
  - 파일 업로드 필드를 통해 전송된 파일(이미지 파일)

  - 포스트 요청일 경우 실행된다(사용자가 수정한 리뷰 데이터를 서버로 전송), 두 종류의 데이터 모두 사용자가 폼을 통해 제출한 새로운(혹은 수정된) 데이터입니다. 원래 작성된 리뷰 데이터는 review 객체에 저장되어 있으며, 폼이 처음 생성될 때 instance=review를 통해 폼에 초기값으로 설정됩니다.(기존 리뷰 값으로 표시)


- 기존 데이터 활용
  - get 요청 시 사용된다(사용자가 리뷰 수정 페이지를 처음 열 때), instance=review로 기존 리뷰 데이터로 미리 채워지고 작동 후 기존 리뷰 내용을 보고 수정할 수 있게 하였습니다.
    
```python
form = ReviewForm(instance=review)
```

#### 3-3 해결 방법:
- 조건문을 사용하여 다양한 이미지 처리 상황을 구분했습니다.
- 이 코드에서는 새 이미지가 업로드된 경우 기존 이미지를 대체하고, 이미지 삭제 옵션이 선택된 경우 이미지 필드를 None으로 설정합니다. 이를 통해 이미지의 추가, 변경, 삭제를 모두 처리할 수 있습니다.
  - (1)request.FILES['image']를 직접 사용했지만, 이제는 ContentFile을 사용하여 파일 내용을 읽고 새로운 파일 객체를 생성합니다.
  - (2)form의 데이터로 review 객체를 생성하지만, 아직 데이터베이스에 저장하지 않습니다. (이를 통해 이미지 처리를 포함한 추가 작업을 수행한 후 최종적으로 저장)
  - (3)save=False 파라미터를 사용하여 이미지 필드만 업데이트하고, 전체 모델은 아직 저장하지 않습니다
  - (4)최종 저장 
  - 이 순으로 작동되게 만들어 "I/O operation on closed file" 오류를 해결하고, 파일 업로드 과정을 더 안정적으로 만들었습니다.
<br><br/>

### 4. 미구현 기능 및 향후 계획

- 주문 시스템과의 연동 미구현: 현재 주문 시스템과의 자동 연동 기능이 구현되지 않았으며, admin에서 직접 주문상태를 'delivered'로 설정하여 사용 중입니다.

- 제품 상세 페이지에서 평균 별점 표시 기능 미구현: 제품의 평균 별점을 사용자에게 표시하는 기능이 아직 구현되지 않았습니다.

- 리뷰 정렬 방식: 제품 상세 페이지에서 리뷰를 추천순, 최신순으로 나열하는 기능을 구상했으나 리뷰 추천 기능을 만들지 못해 아직 구현되지 않았습니다.

- 마이페이지 리뷰 부분에서 html, css 문제로 클릭 전에 화면이 표시되지 않는 구간이 있습니다.

- 3차 프로젝트에서는 이번에 끝내지 못한 주문 시스템과의 연동, 리뷰의 좋아요 기능을 통해 리뷰 정렬 방식 개선, 평균 별점 표시, html과 css파일 재정리, 신고 기능을 구현하고 싶습니다.
가장 중점으로 생각하고 있는 부분은 리뷰 작성률, 증감 추이, 구매자 정보 통계 등 각 리뷰의 통계를 세분화해 시각적으로 표현하는 부분을 만들어 보고 싶습니다.  

### 5. 이번 프로젝트로 느낀 점
- 모든 파일을 통합 시킬때 오류가 생각보다 많이나서 정해진 경로를 따르지 않고 개인적으로 작업한 형식의 파일로 통합을 시켜 추후 기능을 추가할때 두 번 일하는 일이 발생했습니다.

  이 일로 시간이 많이 지체되어 구현 할 수 있었던 것도 시간 부족이 된거 같아 팀원에게 미안함을 느끼고 있고 이번 프로젝트를 통해 소통의 중요성을 많이 깨닳은거 같습니다.

  3차 때는 초기의 설계 단계에서 맡은 기능의 구체적인 내용과 진행 상황을 수시로 공유하여 깔끔하게 진행되도록 노력해보겠습니다.
